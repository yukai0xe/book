---
outline: deep
---

# 運算式與運算子

JavaScript 的運算子基本上與其他語言差不多，所以只會挑選幾個特的用法說明

## 運算子類型

- 賦值運算子：`=`、`+=`
- 比較運算子：`==`、`>=`、`<=`
- 算數運算子：`++`、`--`、`%`、`**`
- 邏輯運算子：`&&`、`||`、`!`
- 字串運算子：`'Hello' + 'World!'`

以上只是些舉例，詳細內容還請見[文檔](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators)

## 算術運算子

在算數運算子和字串運算子裡，都有 `+` 這個符號，所以會根據前後的資料型別而有不同的結果。
而其他運算式則會自動用 `Number()`、`valueOf()` 把其他型別轉成 `number‵

| 運算式          | 結果     | 說明                                |
|-----------------|----------|-------------------------------------|
| `3 + '3'`        | `"33"`   | `+` 被視為字串運算子                    |
| `3 - '3'`        | `0`      | `3 - Number('3')`                  |
| `'3' * '3'`      | `9`      | `Number('3') * Number('3')`        |
| `15 / null`      | `Infinity` | `15 / Number(null)`，`null → 0`     |
| `15 / undefined` | `NaN`    | `15 / Number(undefined)`           |
| `7 * []`         | `0`      | `7 * [].valueOf()`，`[].valueOf() = 0` |
| `123 + null`     | `123`    | `123 + Number(null)`，`null → 0`     |
| `3 + true`       | `4`      | `3 + Number(true)`，`true → 1`       |


## 字串運算子

呈上述，只要 `+` 的兩端其中一端為字串，或者，兩邊的資料型別不同，就會將 `+` 視為字串運算子，兩端的資料型別則會根據以下規則進行轉換

- 基本型別用 `toString()`
- 物件型別用 `valueOf()`，如果無法轉換就用 `toString()`

| 運算式                              | 結果                                 | 說明      |
|-------------------------------------|--------------------------------------|----------------------------------|
| `"123" + 3`                         | `"1233"`                             | `3.toString()` → `"3"`    |
| `"123" + true`                      | `"123true"`                          | `true.toString()` → `"true"`    |
| `"3" + undefined`                   | `"3undefined"`                       | `undefined.toString()` → `"undefined"`    |
| `3 + []`                            | `"3"`                                | `[].toString()` → `""`      |
| `3 + {}`                            | `"3[object Object]"`                 | `({}).toString()` → `"[object Object]"`      |
| `12 + [1, 2, 3, 4]`                 | `"121,2,3,4"`                         | 陣列以 `join(',')` 的方式被轉為字串        |
| `12 + function(){console.log("Hello")}` | `"12function(){console.log(\"Hello\")}"` | `function.toString()` → 函式原始碼字串      |
| `12 + (() => console.log("Hello"))` | `"12() => console.log(\"Hello\")"`   | 箭頭函式也會 `toString()` 成為其原始碼  |


## 賦值運算子

**一行寫法拆解**

根據由右賦值給左的原理，我們可以寫出下面式子

```js
a += b *= c -= d
```

這樣等同於

```js
c -= d
b *= c - d
a += b * ( c - d )
```

## 比較運算子

`==` 會容許在比較時自動轉型，但 `===` 不容許在比較時自動轉型
至於 `==` 的比較結果如何，請見下表：

| 表達式            | 結果   | 說明                                                                |
|-------------------|--------|---------------------------------------------------------------------|
| `10 == '10'`       | `true` | 非嚴格相等，`'10'` 會被轉成數字比較                                 |
| `10 === 10`        | `true` | 嚴格相等，型別和值都相同                                            |
| `'10' == true`     | `false`| `Number('10') === 10`，`true` 轉成 1，不相等                         |
| `10 === 1`         | `false`| 嚴格比較，不相等                                                    |
| `10 == true`       | `false`| `Number(true) = 1`，不相等                                          |
| `false == 0`       | `true` | `false → 0`，`0 == 0`                                                |
| `true == 1`        | `true` | `true → 1`，`1 == 1`                                                 |
| `true == 'true'`   | `false`| `'true'` 無法轉成數字 → `NaN`，不相等                               |
| `false == 'false'` | `false`| 同上：`'false'` → `NaN`，不相等                                     |
| `1 === NaN`        | `false`| `NaN` 與任何值都不相等，包括自己                                     |
| `0 === NaN`        | `false`| 同上                                                                |
| `[] == 0`          | `true` | `[].toString() = ''`，`Number('') = 0`                              |
| `[] == ''`         | `true` | `[].toString() = ''`                                                |
| `[''] == 0`        | `true` | `[''].toString() = '' → 0`                                          |
| `[0] == 0`         | `true` | `[0].toString() = '0' → 0`                                          |
| `[1] == 0`         | `false`| `[1] → 1`，不等於 0                                                 |
| `[0] == ''`        | `false`| `[0] → '0'`，`'0' != ''`                                            |
| `[] == []`         | `false`| 兩個 array 記憶體位址不同                                           |
| `{}` == {}         | `false`| 兩個 object 記憶體位址不同                                          |
| `null == undefined`| `true` | ECMAScript 特例：兩者鬆散比較相等                                   |


所以為了避免超怪例外的發生，我們在進行比較時，一律建議使用 `===`、`!==`