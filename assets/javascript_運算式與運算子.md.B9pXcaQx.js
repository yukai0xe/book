import{_ as t,c as e,o,ai as c}from"./chunks/framework.BS5liULo.js";const p=JSON.parse('{"title":"運算式與運算子","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"javascript/運算式與運算子.md","filePath":"javascript/運算式與運算子.md"}'),a={name:"javascript/運算式與運算子.md"};function r(i,d,s,l,n,h){return o(),e("div",null,d[0]||(d[0]=[c(`<h1 id="運算式與運算子" tabindex="-1">運算式與運算子 <a class="header-anchor" href="#運算式與運算子" aria-label="Permalink to &quot;運算式與運算子&quot;">​</a></h1><p>JavaScript 的運算子基本上與其他語言差不多，所以只會挑選幾個特的用法說明</p><h2 id="運算子類型" tabindex="-1">運算子類型 <a class="header-anchor" href="#運算子類型" aria-label="Permalink to &quot;運算子類型&quot;">​</a></h2><ul><li>賦值運算子：<code>=</code>、<code>+=</code></li><li>比較運算子：<code>==</code>、<code>&gt;=</code>、<code>&lt;=</code></li><li>算數運算子：<code>++</code>、<code>--</code>、<code>%</code>、<code>**</code></li><li>邏輯運算子：<code>&amp;&amp;</code>、<code>||</code>、<code>!</code></li><li>字串運算子：<code>&#39;Hello&#39; + &#39;World!&#39;</code></li></ul><p>以上只是些舉例，詳細內容還請見<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators" target="_blank" rel="noreferrer">文檔</a></p><h2 id="算術運算子" tabindex="-1">算術運算子 <a class="header-anchor" href="#算術運算子" aria-label="Permalink to &quot;算術運算子&quot;">​</a></h2><p>在算數運算子和字串運算子裡，都有 <code>+</code> 這個符號，所以會根據前後的資料型別而有不同的結果。 而其他運算式則會自動用 <code>Number()</code>、<code>valueOf()</code> 把其他型別轉成 \`number‵</p><table tabindex="0"><thead><tr><th>運算式</th><th>結果</th><th>說明</th></tr></thead><tbody><tr><td><code>3 + &#39;3&#39;</code></td><td><code>&quot;33&quot;</code></td><td><code>+</code> 被視為字串運算子</td></tr><tr><td><code>3 - &#39;3&#39;</code></td><td><code>0</code></td><td><code>3 - Number(&#39;3&#39;)</code></td></tr><tr><td><code>&#39;3&#39; * &#39;3&#39;</code></td><td><code>9</code></td><td><code>Number(&#39;3&#39;) * Number(&#39;3&#39;)</code></td></tr><tr><td><code>15 / null</code></td><td><code>Infinity</code></td><td><code>15 / Number(null)</code>，<code>null → 0</code></td></tr><tr><td><code>15 / undefined</code></td><td><code>NaN</code></td><td><code>15 / Number(undefined)</code></td></tr><tr><td><code>7 * []</code></td><td><code>0</code></td><td><code>7 * [].valueOf()</code>，<code>[].valueOf() = 0</code></td></tr><tr><td><code>123 + null</code></td><td><code>123</code></td><td><code>123 + Number(null)</code>，<code>null → 0</code></td></tr><tr><td><code>3 + true</code></td><td><code>4</code></td><td><code>3 + Number(true)</code>，<code>true → 1</code></td></tr></tbody></table><h2 id="字串運算子" tabindex="-1">字串運算子 <a class="header-anchor" href="#字串運算子" aria-label="Permalink to &quot;字串運算子&quot;">​</a></h2><p>呈上述，只要 <code>+</code> 的兩端其中一端為字串，或者，兩邊的資料型別不同，就會將 <code>+</code> 視為字串運算子，兩端的資料型別則會根據以下規則進行轉換</p><ul><li>基本型別用 <code>toString()</code></li><li>物件型別用 <code>valueOf()</code>，如果無法轉換就用 <code>toString()</code></li></ul><table tabindex="0"><thead><tr><th>運算式</th><th>結果</th><th>說明</th></tr></thead><tbody><tr><td><code>&quot;123&quot; + 3</code></td><td><code>&quot;1233&quot;</code></td><td><code>3.toString()</code> → <code>&quot;3&quot;</code></td></tr><tr><td><code>&quot;123&quot; + true</code></td><td><code>&quot;123true&quot;</code></td><td><code>true.toString()</code> → <code>&quot;true&quot;</code></td></tr><tr><td><code>&quot;3&quot; + undefined</code></td><td><code>&quot;3undefined&quot;</code></td><td><code>undefined.toString()</code> → <code>&quot;undefined&quot;</code></td></tr><tr><td><code>3 + []</code></td><td><code>&quot;3&quot;</code></td><td><code>[].toString()</code> → <code>&quot;&quot;</code></td></tr><tr><td><code>3 + {}</code></td><td><code>&quot;3[object Object]&quot;</code></td><td><code>({}).toString()</code> → <code>&quot;[object Object]&quot;</code></td></tr><tr><td><code>12 + [1, 2, 3, 4]</code></td><td><code>&quot;121,2,3,4&quot;</code></td><td>陣列以 <code>join(&#39;,&#39;)</code> 的方式被轉為字串</td></tr><tr><td><code>12 + function(){console.log(&quot;Hello&quot;)}</code></td><td><code>&quot;12function(){console.log(\\&quot;Hello\\&quot;)}&quot;</code></td><td><code>function.toString()</code> → 函式原始碼字串</td></tr><tr><td><code>12 + (() =&gt; console.log(&quot;Hello&quot;))</code></td><td><code>&quot;12() =&gt; console.log(\\&quot;Hello\\&quot;)&quot;</code></td><td>箭頭函式也會 <code>toString()</code> 成為其原始碼</td></tr></tbody></table><h2 id="賦值運算子" tabindex="-1">賦值運算子 <a class="header-anchor" href="#賦值運算子" aria-label="Permalink to &quot;賦值運算子&quot;">​</a></h2><p><strong>一行寫法拆解</strong></p><p>根據由右賦值給左的原理，我們可以寫出下面式子</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span></code></pre></div><p>這樣等同於</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ( c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d )</span></span></code></pre></div><h2 id="比較運算子" tabindex="-1">比較運算子 <a class="header-anchor" href="#比較運算子" aria-label="Permalink to &quot;比較運算子&quot;">​</a></h2><p><code>==</code> 會容許在比較時自動轉型，但 <code>===</code> 不容許在比較時自動轉型 至於 <code>==</code> 的比較結果如何，請見下表：</p><table tabindex="0"><thead><tr><th>表達式</th><th>結果</th><th>說明</th></tr></thead><tbody><tr><td><code>10 == &#39;10&#39;</code></td><td><code>true</code></td><td>非嚴格相等，<code>&#39;10&#39;</code> 會被轉成數字比較</td></tr><tr><td><code>10 === 10</code></td><td><code>true</code></td><td>嚴格相等，型別和值都相同</td></tr><tr><td><code>&#39;10&#39; == true</code></td><td><code>false</code></td><td><code>Number(&#39;10&#39;) === 10</code>，<code>true</code> 轉成 1，不相等</td></tr><tr><td><code>10 === 1</code></td><td><code>false</code></td><td>嚴格比較，不相等</td></tr><tr><td><code>10 == true</code></td><td><code>false</code></td><td><code>Number(true) = 1</code>，不相等</td></tr><tr><td><code>false == 0</code></td><td><code>true</code></td><td><code>false → 0</code>，<code>0 == 0</code></td></tr><tr><td><code>true == 1</code></td><td><code>true</code></td><td><code>true → 1</code>，<code>1 == 1</code></td></tr><tr><td><code>true == &#39;true&#39;</code></td><td><code>false</code></td><td><code>&#39;true&#39;</code> 無法轉成數字 → <code>NaN</code>，不相等</td></tr><tr><td><code>false == &#39;false&#39;</code></td><td><code>false</code></td><td>同上：<code>&#39;false&#39;</code> → <code>NaN</code>，不相等</td></tr><tr><td><code>1 === NaN</code></td><td><code>false</code></td><td><code>NaN</code> 與任何值都不相等，包括自己</td></tr><tr><td><code>0 === NaN</code></td><td><code>false</code></td><td>同上</td></tr><tr><td><code>[] == 0</code></td><td><code>true</code></td><td><code>[].toString() = &#39;&#39;</code>，<code>Number(&#39;&#39;) = 0</code></td></tr><tr><td><code>[] == &#39;&#39;</code></td><td><code>true</code></td><td><code>[].toString() = &#39;&#39;</code></td></tr><tr><td><code>[&#39;&#39;] == 0</code></td><td><code>true</code></td><td><code>[&#39;&#39;].toString() = &#39;&#39; → 0</code></td></tr><tr><td><code>[0] == 0</code></td><td><code>true</code></td><td><code>[0].toString() = &#39;0&#39; → 0</code></td></tr><tr><td><code>[1] == 0</code></td><td><code>false</code></td><td><code>[1] → 1</code>，不等於 0</td></tr><tr><td><code>[0] == &#39;&#39;</code></td><td><code>false</code></td><td><code>[0] → &#39;0&#39;</code>，<code>&#39;0&#39; != &#39;&#39;</code></td></tr><tr><td><code>[] == []</code></td><td><code>false</code></td><td>兩個 array 記憶體位址不同</td></tr><tr><td><code>{}</code> == {}</td><td><code>false</code></td><td>兩個 object 記憶體位址不同</td></tr><tr><td><code>null == undefined</code></td><td><code>true</code></td><td>ECMAScript 特例：兩者鬆散比較相等</td></tr></tbody></table><p>所以為了避免超怪例外的發生，我們在進行比較時，一律建議使用 <code>===</code>、<code>!==</code></p>`,22)]))}const k=t(a,[["render",r]]);export{p as __pageData,k as default};
